{
    "tips": [
        "Tip 1: Understand the problem constraints. For example, if the input size is up to 10^5, an O(n^2) solution will likely timeout. Aim for O(n log n) or better.",
        "Tip 2: Always analyze the time and space complexity of your solution. For example, a nested loop over an array of size n results in O(n^2) time complexity.",
        "Tip 3: Start with a brute-force solution if you're stuck. For example, for finding two numbers that add up to a target, use two nested loops:\n```\nfor (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n        if (arr[i] + arr[j] == target)\n            return [i, j];\n```",
        "Tip 4: Test your code with edge cases. For example, for a problem involving arrays, test with:\n- An empty array: `[]`\n- An array with one element: `[5]`\n- An array with duplicate values: `[1, 2, 2, 3]`",
        "Tip 5: Use the LeetCode playground to debug your code. For example, print intermediate values:\n```\nconsole.log('Current value:', arr[i]);\n```",
        "Tip 6: Read the problem description carefully. For example, if the problem says 'return the indices,' don't return the values.",
        "Tip 7: Practice writing clean and readable code. For example, use meaningful variable names:\n```\nlet totalScore = 0; // Good\nlet ts = 0; // Bad\n```",
        "Tip 8: Learn to recognize common problem patterns. For example, for the Two Pointer technique:\n```\nlet left = 0, right = arr.length - 1;\nwhile (left < right) {\n    if (arr[left] + arr[right] == target)\n        return [left, right];\n    else if (arr[left] + arr[right] < target)\n        left++;\n    else\n        right--;\n}\n```",
        "Tip 9: Don't spend too much time on one problem. If you're stuck after 20-30 minutes, take a break or move to another problem.",
        "Tip 10: Use LeetCode's discuss section to learn from others' solutions. For example, search for 'Two Sum optimal solution' to see better approaches.",
        "Tip 11: For array problems, consider using the Two Pointer technique. For example, to remove duplicates from a sorted array:\n```\nlet i = 0;\nfor (let j = 1; j < arr.length; j++)\n    if (arr[j] != arr[i])\n        arr[++i] = arr[j];\nreturn i + 1;\n```",
        "Tip 12: If the problem involves searching in a sorted array, think about Binary Search. For example:\n```\nlet left = 0, right = arr.length - 1;\nwhile (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (arr[mid] == target)\n        return mid;\n    else if (arr[mid] < target)\n        left = mid + 1;\n    else\n        right = mid - 1;\n}\nreturn -1;\n```",
        "Tip 13: For problems involving subarrays or substrings, consider the Sliding Window technique. For example, to find the maximum sum of a subarray of size k:\n```\nlet maxSum = 0, windowSum = 0;\nfor (let i = 0; i < k; i++)\n    windowSum += arr[i];\nmaxSum = windowSum;\nfor (let i = k; i < arr.length; i++) {\n    windowSum += arr[i] - arr[i - k];\n    maxSum = Math.max(maxSum, windowSum);\n}\nreturn maxSum;\n```",
        "Tip 14: When dealing with strings, remember that many problems can be solved using hash maps to count character frequencies. For example, to check if two strings are anagrams:\n```\nlet map = new Map();\nfor (let char of str1)\n    map.set(char, (map.get(char) || 0) + 1);\nfor (let char of str2)\n    if (!map.has(char) || map.get(char) == 0)\n        return false;\n    else\n        map.set(char, map.get(char) - 1);\nreturn true;\n```",
        "Tip 15: For tree problems, use Depth-First Search (DFS) for traversals. For example, to perform an inorder traversal:\n```\nfunction inorder(root) {\n    if (!root) return;\n    inorder(root.left);\n    console.log(root.val);\n    inorder(root.right);\n}\n```",
        "Tip 16: If the problem involves finding the shortest path or minimum steps, consider BFS. For example, to find the shortest path in a binary tree:\n```\nlet queue = [root], level = 0;\nwhile (queue.length) {\n    let size = queue.length;\n    for (let i = 0; i < size; i++) {\n        let node = queue.shift();\n        if (!node.left && !node.right)\n            return level;\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n    }\n    level++;\n}\n```",
        "Tip 17: For problems involving combinations or permutations, think about Backtracking. For example, to generate all subsets:\n```\nfunction backtrack(start, path) {\n    result.push([...path]);\n    for (let i = start; i < nums.length; i++) {\n        path.push(nums[i]);\n        backtrack(i + 1, path);\n        path.pop();\n    }\n}\n```",
        "Tip 18: When dealing with intervals, consider sorting them first. For example, to merge overlapping intervals:\n```\nintervals.sort((a, b) => a[0] - b[0]);\nlet result = [intervals[0]];\nfor (let i = 1; i < intervals.length; i++) {\n    let last = result[result.length - 1];\n    if (intervals[i][0] <= last[1])\n        last[1] = Math.max(last[1], intervals[i][1]);\n    else\n        result.push(intervals[i]);\n}\nreturn result;\n```",
        "Tip 19: For problems involving graphs, use Union-Find (Disjoint Set Union) to efficiently manage connected components. For example:\n```\nlet parent = [];\nfunction find(x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\nfunction union(x, y) {\n    parent[find(x)] = find(y);\n}\n```",
        "Tip 20: If the problem involves finding the maximum or minimum value, consider using a Heap (Priority Queue). For example, to find the top k elements:\n```\nlet heap = new MinHeap();\nfor (let num of nums) {\n    heap.push(num);\n    if (heap.size() > k)\n        heap.pop();\n}\nreturn heap.toArray();\n```"
    ]
}